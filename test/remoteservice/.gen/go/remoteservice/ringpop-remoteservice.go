// @generated Code generated by thrift-gen. Do not modify.

package remoteservice

import (
	"errors"
	"fmt"

	"github.com/uber/ringpop-go"
	"github.com/uber/ringpop-go/forward"
	"github.com/uber/ringpop-go/router"
	"github.com/uber/tchannel-go"
	"github.com/uber/tchannel-go/thrift"

	"github.com/uber/ringpop-go/test/remoteservice/.gen/go/shared"

	"github.com/uber/ringpop-go/test/remoteservice/.gen/go/unused"
)

var _ = shared.GoUnusedProtection__

var _ = unused.GoUnusedProtection__

type RingpopRemoteServiceAdapter struct {
	impl    TChanRemoteService
	ringpop ringpop.Interface
	ch      *tchannel.Channel
	config  RemoteServiceConfiguration
	router  router.Router
}

// RemoteServiceConfiguration contains the forwarding configuration for the RemoteService service. It has a field for every endpoint defined in the service. In this field the endpoint specific forward configuration can be stored. Populating these fields is optional, default behaviour is to call the service implementation locally to the process where the call came in.
type RemoteServiceConfiguration struct {
	// RemoteCall holds the forwarding configuration for the RemoteCall endpoint defined in the service
	RemoteCall *RemoteServiceRemoteCallConfiguration
}

func (c *RemoteServiceConfiguration) validate() error {
	if c.RemoteCall != nil {
		if c.RemoteCall.Key == nil {
			return errors.New("configuration for endpoint RemoteCall is missing a Key function")
		}
	}
	return nil
}

// NewRingpopRemoteServiceAdapter creates an implementation of the TChanRemoteService interface. This specific implementation will use to configuration provided during construction to deterministically route calls to nodes from a ringpop cluster. The channel should be the channel on which the service exposes its endpoints. Forwarded calls, calls to unconfigured endpoints and calls that already were executed on the right machine will be passed on the the implementation passed in during construction.
//
// Example usage:
//  import "github.com/uber/tchannel-go/thrift"
//
//  var server thrift.Server
//  server = ...
//
//  var handler TChanRemoteService
//  handler = &YourImplementation{}
//
//  adapter, _ := NewRingpopRemoteServiceAdapter(handler, ringpop, channel,
//    RemoteServiceConfiguration{
//      RemoteCall: &RemoteServiceRemoteCallConfiguration: {
//        Key: func(ctx thrift.Context, name shared.Name) (shardKey string, err error) {
//          return "calculated-shard-key", nil
//        },
//      },
//    },
//  )
//  server.Register(NewTChanRemoteServiceServer(adapter))
func NewRingpopRemoteServiceAdapter(
	impl TChanRemoteService,
	rp ringpop.Interface,
	ch *tchannel.Channel,
	config RemoteServiceConfiguration,
) (TChanRemoteService, error) {
	err := config.validate()
	if err != nil {
		return nil, err
	}

	adapter := &RingpopRemoteServiceAdapter{
		impl:    impl,
		ringpop: rp,
		ch:      ch,
		config:  config,
	}
	// create ringpop router for routing based on ring membership
	adapter.router = router.New(rp, adapter, ch)

	return adapter, nil
}

// GetLocalClient satisfies the ClientFactory interface of ringpop-go/router
func (a *RingpopRemoteServiceAdapter) GetLocalClient() interface{} {
	return a.impl
}

// MakeRemoteClient satisfies the ClientFactory interface of ringpop-go/router
func (a *RingpopRemoteServiceAdapter) MakeRemoteClient(client thrift.TChanClient) interface{} {
	return NewTChanRemoteServiceClient(client)
}

// RemoteServiceRemoteCallConfiguration contains the configuration on how to route calls to the thrift endpoint RemoteService::RemoteCall.
type RemoteServiceRemoteCallConfiguration struct {
	// Key is a closure that generates a routable key based on the parameters of the incomming request.
	Key func(ctx thrift.Context, name shared.Name) (string, error)
}

// RemoteCall satisfies the TChanRemoteService interface. This function uses the configuration for RemoteCall to determine the host to execute the call on. When it decides the call needs to be executed in the current process it will forward the invocation to its local implementation.
func (a *RingpopRemoteServiceAdapter) RemoteCall(ctx thrift.Context, name shared.Name) (err error) {
	// check if the function should be called locally
	if a.config.RemoteCall == nil || forward.DeleteForwardedHeader(ctx) {
		return a.impl.RemoteCall(ctx, name)
	}

	// find the key to shard on
	ringpopKey, err := a.config.RemoteCall.Key(ctx, name)
	if err != nil {
		return fmt.Errorf("could not get key: %q", err)
	}

	clientInterface, isRemote, err := a.router.GetClient(ringpopKey)
	if err != nil {
		return err
	}

	client := clientInterface.(TChanRemoteService)
	if isRemote {
		ctx = forward.SetForwardedHeader(ctx, []string{ringpopKey})
	}
	return client.RemoteCall(ctx, name)
}
